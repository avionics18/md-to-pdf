Arrays in Java are dynamically created and can be assigned to variables of type `Object`. All methods of the `java.lang.Object` class can be invoked on an array, such as `toString()`, `equals()`, and `hashCode()`.

While arrays are objects, they are **not instances** of a **programmer-defined class in the traditional sense**. Instead, the Java Virtual Machine (JVM) **dynamically generates a special class for each array type at runtime**. For example, an array of integers (`int[]`) is represented by a dynamically generated class, and similarly for other data types and dimensions. These dynamically generated array classes implicitly inherit from `java.lang.Object`.

In Java, the terms "array" and "Arrays" refer to distinct concepts:

**array (lowercase 'a'):**

This refers to the fundamental data structure in Java. An array is a fixed-size, ordered collection of elements of the same data type. Once an array is declared with a specific size, that size cannot be changed. Elements are accessed using a zero-based index. For example, `int[] numbers = new int[5];` declares an array named `numbers` that can hold five integer values.

**Arrays (uppercase 'A'):**

This refers to a utility class located in the `java.util package`. The `Arrays` class provides a collection of static methods for performing common operations on arrays, such as:

- **Sorting**: `Arrays.sort()`
- **Searching**: `Arrays.binarySearch()`
- **Filling**: `Arrays.fill()`
- **Comparing**: `Arrays.equals()`
- **Converting**: `Arrays.asList()` (to view an array as a `List`)

In essence, an "array" is the data structure itself, while `Arrays` is a helper class that provides convenient methods to manipulate and work with these data structures. You create and use arrays directly, and you invoke static methods from the `Arrays` class to perform operations on those arrays.

<div class="page-break"></div>

When `System.out.println(arr);` is called in Java, where `arr` is an array, it typically prints a **string representation** of the **array's memory address**, *not the contents of the array itself*. This is because arrays in Java *do not override* the `toString()` method inherited from `java.lang.Object`.

The default `Object.toString()` implementation returns a string consisting of the class name, an "@" sign, and the unsigned hexadecimal representation of the object's hash code. For an array, this results in output like:

```java
int[] arr = new int[5];
System.out.println(arr);
```

```sh
# Ouptut
[I@1b6d3586
```

Here:

- `[` indicates it's an 1-D array.
- `I` indicates the type of elements in the array (in this case, `int`). Other types would be represented differently (e.g., `Ljava.lang.String;` (e.g: `[Ljava.lang.String;@36baf30c`) for a String array, `C` for a char array, `Z` for a boolean array, etc.).
- `@` is a separator.
- `1b6d3586` is the *hexadecimal representation* of the array's hash code, which is derived from its memory address.

**Exception for `char` arrays:**

A notable exception to this behavior is when `arr` is a `char` array (i.e., `char[]`). In this specific case, `System.out.println()` is overloaded to directly print the characters contained within the `char` array, effectively treating it like a `String`.

```java
char[] arr = { 'a', 'b', 'c', 'd', 'e' };
System.out.println(arr);
```

```sh
# Output
abcde
```

**To print the contents of other array types:**

To print the actual elements of an array (other than `char[]`), you need to use utility methods provided in the `java.util.Arrays` class, such as:

- `Arrays.toString(arr)`: For one-dimensional arrays, this returns a string representation of the array's contents (e.g., `[1, 2, 3]`).
- `Arrays.deepToString(arr)`: For multi-dimensional arrays, this returns a string representation of the array's contents, including nested arrays.

<div class="page-break"></div>

```java
// Array (Object) Referencing Example

package code.L11__Arrays;

public class C01_Basics {
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3, 4, 5 };
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();

        int[] other = arr;
        other[2] = -28;
        for (int i = 0; i < other.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();

        System.out.println("arr = " + arr);
        System.out.println("other = " + other);
    }
}
```

**Output:**

```
1 2 3 4 5
1 2 -28 4 5        
arr = [I@38af3868  
other = [I@38af3868
```

<div class="page-break"></div>


## Remaining Topics

- `arr.length` data member
- passing array to a function (array referencing)
- `java.lang.ArrayIndexOutOfBoundsException`
- Hard code array `int[] nums = new int[] {1, 2, 3, 4, 5}`
- Array Swap Demo
    - `swap(int a, int b)`
    - `swap(int[] arr, int i, int j)`

    As you can see, the changes made by one function is visible to another function only when the changes are made in the heap memory. If the changes are made in stack memory, then they change only their local variables, and those changes won't be visible to another function.